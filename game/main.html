<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Projection Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }
        .container {
            width: 45%;
        }
        .container canvas {
            width: 100%;
        }
        .controls {
            width: 30%;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .controls input {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
        }
        .controls button {
            padding: 10px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h2>3D Star Distribution</h2>
        <canvas id="starCanvas"></canvas>
    </div>

    <div class="container">
        <h2>Celestial Sphere Projection</h2>
        <div id="celestialSphere"></div>
    </div>

    <div class="controls">
        <h3>Parameters</h3>
        <label for="density">Star Density</label>
        <input type="number" id="density" min="0.001" max="0.1" step="0.001" value="0.01">
        
        <label for="radius">Star Radius</label>
        <input type="number" id="radius" min="1" max="10" value="2">
        
        <label for="horizon">Horizon Distance</label>
        <input type="number" id="horizon" min="10" max="50" value="30">
        
        <button onclick="updateVisualization()">Update Visualization</button>
    </div>

    <script>
        let scene, camera, renderer, starGeometry, starMaterial, starMesh, celestialData;

        // Function to generate stars based on density and size
        function generateStars(density, cubeSize) {
            const nStars = Math.floor(density * cubeSize ** 3);
            const stars = [];
            for (let i = 0; i < nStars; i++) {
                stars.push({
                    x: Math.random() * cubeSize - cubeSize / 2,
                    y: Math.random() * cubeSize - cubeSize / 2,
                    z: Math.random() * cubeSize - cubeSize / 2
                });
            }
            return stars;
        }

        // Function to project stars onto a celestial sphere
        function projectToSphere(stars, horizon) {
            const projectedStars = [];
            stars.forEach(star => {
                const distance = Math.sqrt(star.x * star.x + star.y * star.y + star.z * star.z);
                if (distance <= horizon) {
                    const ra = Math.atan2(star.y, star.x);
                    const dec = Math.asin(star.z / distance);
                    projectedStars.push({ ra, dec });
                }
            });
            return projectedStars;
        }

        // Function to create the 3D star distribution
        function create3DStars(stars, radius) {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('starCanvas') });
            renderer.setSize(window.innerWidth * 0.45, window.innerHeight * 0.45);
            document.body.appendChild(renderer.domElement);

            starGeometry = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            stars.forEach(star => {
                positions.push(star.x, star.y, star.z);
                const size = Math.max(0.1, Math.min(radius / (Math.sqrt(star.x * star.x + star.y * star.y + star.z * star.z) + 1), 1));
                sizes.push(size);
            });
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starMaterial = new THREE.PointsMaterial({ size: 0.2, sizeAttenuation: true, transparent: true, opacity: 0.6 });
            starMesh = new THREE.Points(starGeometry, starMaterial);
            scene.add(starMesh);
            camera.position.z = 50;

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                starMesh.rotation.x += 0.001;
                starMesh.rotation.y += 0.001;
                renderer.render(scene, camera);
            }
            animate();
        }

        // Function to create the celestial sphere projection
        function createCelestialSphereProjection(projectedStars) {
            const raArray = projectedStars.map(star => star.ra);
            const decArray = projectedStars.map(star => star.dec);

            const data = [{
                type: 'scattergeo',
                mode: 'markers',
                lon: raArray,
                lat: decArray,
                marker: { size: 3, opacity: 0.6, color: 'blue' },
            }];
            const layout = {
                geo: {
                    projection: { type: 'mollweide' },
                    showland: true,
                    landcolor: 'rgb(243, 243, 243)',
                    showlakes: false,
                },
                title: 'Celestial Sphere Projection',
                height: 500,
                width: 500,
            };
            Plotly.newPlot('celestialSphere', data, layout);
        }

        // Function to update visualization based on inputs
        function updateVisualization() {
            const density = parseFloat(document.getElementById('density').value);
            const radius = parseFloat(document.getElementById('radius').value);
            const horizon = parseFloat(document.getElementById('horizon').value);
            const stars = generateStars(density, 100); // Cube size is 100
            const projectedStars = projectToSphere(stars, horizon);
            create3DStars(stars, radius);
            createCelestialSphereProjection(projectedStars);
        }

        // Initialize the visualization on page load
        window.onload = function() {
            updateVisualization();
        };
    </script>

</body>
</html>
